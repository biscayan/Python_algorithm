# Chapter 4. 빅오, 자료형
- 컴퓨터과학에서 빅오는 입력값이 커질 때 알고리즘의 실행 시간(시간 복잡도)과 메모리(공간 복잡도)가 어떻게 증가하는지를 분류하는 데 사용되며, 알고리즘의 효율성을 분석하기 위하여 매우 유용하게 활용된다.  

## 빅오
- 빅오는 점근적 실행 시간을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나이다.  
- 점근적 실행 시간이란 입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 함수의 실행 시간의 추이를 의미한다.  
- 점근적 실행 시간은 달리 말하면 시간 복잡도라 할 수 있다. 시간 복잡도의 사전적 정의는 어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도를 의마하며, 계산 복잡도를 표기하는 대표적인 방법이 바로 빅오다.  
- 빅오로 시간 복잡도를 표현할 때는 최고차항만을 표기하며, 계수는 무시한다. 예를 들어, 4n^2+3n+4번 만금 계산하는 함수가 있다는 이 함수의 시간 복잡도는 O(n^2)이 된다.  
- 빅오 표기법의 종류  
    - O(1) : 입력값이 아무리 커도 실행 시간은 일정하다. 최고의 알고리즘이라 할 수 있다. 상수 시간을 갖는 알고리즘은 매우 좋지만 이런 알고리즘을 찾기가 매우 힘들다. O(1)로 실행되는 알고리즘으로는 해시 테이블의 조회 및 삽입이 있다.  
    - O(logn) : 로그는 매우 큰 입력값에도 크게 영향을 받지 않는 편으로 웬만한 n의 크기에 대해서도 매우 견고하다. 대표적인 알고리즘으로는 이진 탐색이 있다.  
    - O(n) : 입력값만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는 데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 선형 시간 알고리즘이라고 하며, 정렬되지 않은 리스트에서 최댓값 또는 최솟값을 찾는 경우가 이에 해당한다.  
    - O(nlogn) : 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당한다. 적어도 모든 수에 대해 한 번 이상은 비교해야 하는 비교 기반 정렬 알고리즘은 아무리 좋은 알고리즘도 O(nlogn)보다 빠를 수 없다.  
    - O(n^2) : 버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당한다.  
    - O(2^n) : 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당한다.  
    - O(n!) : 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제를 브루트 포스로 풀이할 때가 이에 해당한다. 가장 느린 알고리즘으로, 입력값이 조금만 커져도 웬만한 다항시간 내에는 계산이 어렵다.  
- 빅오는 시간 복잡도 외에도 공간 복잡도를 표현하는 데에도 널리 쓰인다.  
- 알고리즘은 흔히 시간과 공간이 트레이드오프 관계다. 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다.  
- 실행 시간이 빠르면서도 공간을 적게 차지하는 알고리즘이 드물지만 존재하기는 한다. 그러나 대부분의 경우에 시간과 공간은 트레이드오프 관계이며 이는 알고리즘의 주요한 특징 중 하나다.  

### 상한과 최악
- 빅오는 상한(가장 늦게 실행될 때)을 의미한다. 이외에도 하한(가장 빨리 실행될 때)을 나타내는 빅오메가, 평균을 의미하는 빅세타가 있다.  
- 학계와 달리 업계에서는 빅세타와 빅오를 하나로 합쳐서 단순화해서 표현하려는 경향이 있다. 평균적인 시간보다는 상한 시간으로 단순화해서 주로 표현하는데, 매번 구분하는 것이 번거롭고 혼동되기도 하며 상한으로만 표현하는 방법이 틀리지 않기 때문이다.  
- 여기서 한 가지 중요한 점은 상한을 최악의 경우와 혼동하는 것인데, 빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 적당하게 표현하는 방법일 뿐, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없다.  
- 빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.  

### 분할 상환 분석
- 분할 상환 분석은 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나다.  
- 분할 상환 또는 상각은 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다.  

### 병렬화
- 일부 알고리즘은 병렬화로 실행 속도를 높일 수 있으며 GPU는 병렬 연산을 위한 대표적인 장치이다.  
- GPU 각각의 코어는 CPU보다 훨씬 더 느리지만 GPU의 코어는 수천여 개로 구성되어 있어, 많아 봐야 수십여 개에 불과한 CPU보다 수백 배 더 많은 연산을 동시에 수행할 수 있다.  
- 예를 들어 CPU가 비행기로 짐을 여러 번 나르는 것이라면, GPU는 배로 수많은 짐을 한 번에 나르는 것이다. 배의 운반 속도는 비행기보다 훨씬 느리지만 더 많은 짐을 동시에 나를 수 있는 것처럼, GPU는 결국 같은 시간에 목적지에 훨씬 더 많은 짐을 나를 수 있다.  

## 자료형

### 파이썬 자료형
#### 숫자
- 파이썬에서는 숫자 정수형으로 int만을 제공한다. 원래 파이썬 버전 2까지는 int와 long을 각각 별도로 제공했지만 버전 3부터는 int 단일형으로 통합되었다.  
#### 매핑
- 매핑타입은 키와 자료형으로 구성된 복합 자료형이며, 파이썬에 내장된 유일한 매핑 자료형은 딕셔너리이다.  
#### 집합
- 파이썬의 집합 자료형인 set은 중복된 값을 갖지 않는 자료형이다.  
#### 시퀀스
- 시퀀스는 어떤 특정 대상의 순서 있는 나열을 뜻한다.  
- str은 문자의 순서 있는 나열로 문자열을 이루는 자료형이며, list는 다양한 값들을 배열 형태의 순서 있는 나열로 구성하는 자료형이다.  
- 시퀀스는 불변과 가변으로 구분하는데 str, tuple, bytes가 불변에 해당하며 list는 가변에 해당한다.  

### 원시 타입
- 원시 타입은 메모리에 정확하게 타입 크기만큼의 공간을 할당하고 그 공간을 오로지 값으로 채워넣는다.  
- 객체는 문자로 변환, 16진수로 변환, 시프팅 같은 비트 조작도 가능하지만, 이를 위한 여러 가지 부가 정보가 추가되므로 메모리 점유율이 늘어나고 당연히 계산 속도 또한 감소한다.  
- 즉, 객체는 편리하고 다양한 기능을 제공하기 위해 일정 부분 속도와 공간을 희생하게 된다.  
- C나 자바는 원시 타입을 지원하지만 파이썬은 원시 타입을 지원하지 않는다.  
- 파이썬은 애초에 편리한 기능 제공에 우선순위를 둔 언어인 만큼 느린 속도와 더 많은 메모리를 차지하더라도 훨씬 더 다양한 기능을 제공할 수 있는 객체에 관심을 두는 게 당연하다.  

    |언어|지원 타입 형태|
    |:---:|:---:|
    |C|원시 타입|
    |자바|원시 타입, 객체|
    |파이썬|객체|

### 객체
- 파이썬은 모든 것이 객체다. 그 중에서 크게 불변 객체와 가변 객체로 구분할 수 있다.  

    |클래스|불변/가변|
    |:---:|:---:|
    |bool|불변|
    |int|불변|
    |float|불변|
    |list|가변|
    |tuple|불변|
    |str|불변|
    |set|가변|
    |dict|가변|