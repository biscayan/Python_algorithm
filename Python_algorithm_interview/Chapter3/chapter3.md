# Chapter 3. 파이썬

## 파이썬 문법

### 네이밍 컨벤션
파이썬의 변수명, 함수명 네이밍 컨벤션은 자바, C언어와 달리 각 단어를 밑줄로 구분하여 표기하는 스네이크 케이스를 따른다.  
- 카멜 케이스 -> camelCase / 스네이크 케이스 -> snake_case / 파스칼케이스 -> PascalCase  

### 타입 힌트
파이썬에서는 파라미터와 리턴값의 타입을 지정해주지 않아도 되지만 타입을 명시적으로 선언한다면 가독성도 좋아지고 버그 발생 확률을 줄일 수 있다.  
```python
def fn(a: int) -> bool:
    if a == 0:
        return False
    else:
        return True
```

### 리스트 컴프리헨션
리스트 컴프리헨션이란 기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문이다. 리스트 컴프리헨션은 람다 표현식에 map이나 filter를 섞어서 사용하는 것보다 가독성이 좋다.  
```python
[n*2 for n in range(1,11) if n % 2 == 1]

>>> [2,6,10,14,18]
```
하지만, 리스트 컴프리헨션을 무리하게 작성할 경우에는 오히려 가독성을 떨어뜨릴 수 있으므로 적절히 사용하는 것이 좋다. 대체로 표현식은 2개를 넘지 않아야 한다.  

### 제너레이터
제너레이터는 루프의 반복 동작을 제어할 수 있는 루틴 형태를 말한다. yield 구문을 사용하면 제너레이터를 리턴할 수 있다.  
기존의 함수는 return 구문을 만나면 값을 리턴하고 모든 함수의 동작을 종료하지만, yiled는 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행된다.  
```python
def get_natural_number():
    n = 0
    while True:
        n += 1
        yield n

g = get_natural_number()

for _ in range(100):
    print(next(g))

1
2
...
99
100
```
제너레이터의 방식을 활용하는 대표적인 함수로는 range()가 있다.  

### // 나눗셈 연산자
파이썬에서 몫을 구할 때는 //연산자, 나머지를 구할 때는 %연산자를 사용하면 된다.  
또한 divmod() 함수를 사용하면 몫과 나머지를 동시에 구할 수 있다.
```python
>>> divmod(5,3)
(1,2)
```

### pass
코딩을 하다 보면 일단 코드의 전체 골격을 잡아 놓고 내부에서 처리할 내용을 차근차근 생각하며 만들겠다는 의도로 코딩을 하는 경우가 있다.  
하지만 아래와 같은 경우는 오류가 발생하게 된다.
```python
class MyClass(object):
    def method_a(self):

    def method_b(Self):
        print("Method B")
```
method_a에서 아무런 처리를 하지 않았기 때문에 문제가 발생한 것인데, 오류 메시지를 보면 method_b에서 오류가 발생한 것처럼 보인다.  
한참 개발을 하던 중에 이런 오류를 맞닥뜨리면 생각보다 처리하기가 번거롭다.  
pass는 이런 오류를 막는 역할을 한다. pass를 지정하면 인덴트 오류와 같이 불필요한 오류를 방지할 수 있다.  
```python
class MyClass(object):
    def method_a(self):
        pass

    def method_b(Self):
        print("Method B")
```

### locals
locals()는 로컬 심볼 테이블 딕셔너리를 가져오는 메소드이다. 로컬에 선언된 모든 변수를 조회할 수 있는 강력한 명렁이므로 디버깅에 많은 도움이 된다.  
특히, 로컬 스코프에 제한해 정보를 조회할 수 있기 때문에 클래스의 특정 메소드 내부에서나 함수 내부의 로컬 정보를 조회해 잘못 선언한 부분이 없는지 확인하는 용도로 사용할 수 있다.  
```python
import pprint
pprint.pprint(locals())
```

## 코딩 스타일